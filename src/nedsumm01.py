# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.4.2
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# +
#samenvatting van NED data
# -

import pandas as pd
import numpy as np
import re
import io
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import subprocess
import requests
import json
import os

from ipywidgets import Dropdown, Button, Output, interact
from IPython.display import display

# +
#nu opslag parametriseren, eerst generiek model
# -

feature_list=['tosto']
stoex = pd.DataFrame(0.0, index=np.arange(100), columns=feature_list) 
stoex.at[3,"tosto"]=1
stoex.plot()
stoex.dtypes


def memfunc(times,initst,halfw,mins,maxs):
    state=initst
    decval=1-np.log(2)/halfw
#    print(decval)
    a=times.copy()
    with np.nditer(a, op_flags=['readwrite'], order='K') as it:
        for x in it:
            state += x
            if state > maxs:
                state=maxs
            if state < mins:
                state=mins
            x[...] =  state
            state *=decval
    return a
stoex['storst1']=memfunc(stoex['tosto'],0.0,40,0,0.5)
print(stoex['storst1'][43])
stoex['storst1'].plot()

# +
#ophalen generieke gegevens
# -

energytypes=pd.read_csv("../data/energytypes.txt",sep=" ").set_index('index')
energytypes
energytypes_dict=energytypes.to_dict()['Energytype']
energytypes_dict

#referentie gegevens in TJ
regklimmon23_map={0: 349280, 23: 800547, 26: 432838}

#generated by klimmon_explore van regionale klimaat monitor, in TJ
landverbrcat=pd.read_excel('../data/rkm-landverbrcat.xlsx')
#print (landverbrcat.columns)
landverbrcatm = landverbrcat.melt(id_vars=['ExternalCode', 'GeoLevel', 'PeriodLevel', 'Period', 'VarName'],
                                 value_name='fromklimmon_TJ')
regklimmon_fieldmap={'elektra_totaal_combi': 0, 'gas_totaal_won_zak_combi':23, 'verk_totaal':26}
landverbrcatm['energytypenr'] = landverbrcatm['variable'] .map(regklimmon_fieldmap)
landverbrcatm = landverbrcatm[ ( landverbrcatm['energytypenr'].isna() ==False ) & (landverbrcatm['Period'] >=2022)].copy()
landverbrcatm = landverbrcatm.rename(columns={'Period': 'jaar'})[['jaar','energytypenr','fromklimmon_TJ']]
landverbrcatm['fromklimmon_GWh'] = landverbrcatm['fromklimmon_TJ']/3.6
landverbrcatm

regklimmon23GWh_map =  landverbrcatm[  (landverbrcatm['jaar'] ==2023)]. set_index('energytypenr')['fromklimmon_GWh'].to_dict()
regklimmon23GWh_map

# +
#ophalen jaargegevens
# -

tst_yrtomodel='2025'


#haal gegevens op, zodat laden (waar API key voor nodig is) maak 1 maal hoeft
def getyrdta(my_yrtomodel):
    egasyr_l=pd.read_pickle("../intermediate/egasyr"+str(my_yrtomodel)+".pkl")
    #egasyr.dtypes
    #en doe berekeningen in GWh, en niet in kWh
    egasyr_l['volume']=egasyr_l['volume']*1e-6
    egasyr_l['jaar'] = int(my_yrtomodel)
    return( egasyr_l)
egasyr= getyrdta(tst_yrtomodel)    
egasyr

yrstomodel='2022-5'
allyr= pd.concat ([getyrdta(my_yrtomodel) for my_yrtomodel in range (2022 , 2026)  ] )

yrtomodel='2025'
egasyr=allyr[allyr['jaar'] == int (yrtomodel)]
if True:
    egasyr=allyr
    yrtomodel=yrstomodel

#maak kleine sets om de eerste paar dagen mee te plotten
maxd=yrtomodel+"-01-16T00:00:00+00:00"
psett=egasyr[(egasyr['validfrom']< pd.to_datetime(maxd))]
#maar gebruik nu hele jaar
psett=egasyr
pset2=psett[(psett['activity']=='/v1/activities/2')  ]
pset2
pset1=psett[(psett['activity']=='/v1/activities/1')  ]
pset1

#hieruit kan e.v.t worden geprobeerd de 25 % missend gasverbruik te reconstrueren
gassums= pset2.groupby(["energytype","energytypenr",'jaar'])['volume'].agg('sum')/ regklimmon23GWh_map[23]
print (gassums)
if yrtomodel!=yrstomodel:
    dv=gassums.reset_index('energytype','jaar')['volume'].to_dict()
    print(dv[23]+dv[31])
    if yrtomodel < '2025':
        print(dv[53]+dv[54]+dv[55])


# +
def mkrestcat(df,defs,rtype):
    allcols=set(df.columns)
    summcols=allcols-set(["@id","id","type","@type","volume","capacity","percentage","emission",
                          "energytype","energytypenr","emissionfactor","lastupdate",
                          "activity"])
#    print(summcols)
    dfcalc=df.copy()
    mmap= dfcalc['energytypenr'].map(defs)
    
    dfcalc['volume']=(mmap)*dfcalc['volume']
    dfcalc['capacity']=(mmap)*dfcalc['capacity']
    dfcalc['emission']=(mmap)*dfcalc['emission']
    dfcalc=dfcalc[False==pd.isna(mmap) ]    

    dfcalc=dfcalc.groupby( list(summcols) ).agg('sum').reset_index()
    dfcalc['energytypenr']=rtype
    dfcalc['energytype']=str(rtype)+ " - "+ energytypes_dict[rtype]
    return dfcalc
    
plt.clf()
#check waarde om verschil te begrijpen
pset2r=mkrestcat(pset2,{23:1,54:-0.2,55:-1},26)
print(pset2r.dtypes)
#print(pset2.agg('min'))
sns.scatterplot(data=pd.concat([pset2r,pset2]),x="validfrom",y="volume",hue="energytype")    
# -

pset1r=mkrestcat(pset1,{0:1,1:-1,2:-1,17:-1},10)
#print(pset1r)
#waarde om rest opwek te begrijpen
sns.scatterplot(data=pd.concat([pset1r,pset1]),x="validfrom",y="volume",hue="energytype")  
plt.title('Opwek:bronnen, in 0: duurzame opwek')

#maak plot eerste dagen
pset1t=mkrestcat(pd.concat ( [pset1,pset2]) ,{0:1,23:1},10)
pset1tkw=pset1t.copy()
pset1tkw['volume']=pset1tkw['volume']
sns.scatterplot(data=pset1tkw,x="validfrom",y="volume",hue="energytype")  

some_string="""inst,vbfact,vbverd,omschr
A,1,0,data + voertuig glad"""
#read CSV string into pandas DataFrame
param_verbr_df= pd.read_csv(io.StringIO(some_string), sep=",").set_index('inst')
print(param_verbr_df)


# +
def mkcombiset(yrindat):
    yset2=yrindat[(yrindat['activity']=='/v1/activities/2')  ]
#    yset2
    yset1=yrindat[(yrindat['activity']=='/v1/activities/1')  ]
#    yset1
    

    yset1t=mkrestcat(yrindat ,{0:1,23:1},10)
    yset1tkw=yset1t.copy()
    yset1tkw['volume']=yset1tkw['volume']
    sns.scatterplot(data=yset1tkw,x="validfrom",y="volume",hue="energytype") 
    yset1t0=yset1[yset1['energytypenr']==0]
    yset2t23=yset2[yset2['energytypenr']==23]
    #voeg voertuigbrandstoffen toe, in gelijke mate per uur
    #daardoor ontstaat niet-gepiekt (wel planbaar !) verbruik
    yset7t23_2023_sum=regklimmon23GWh_map[26]
    yset7t23=yset2t23.copy()
    yset7t23['volume']= yset7t23_2023_sum/(24*365)
    yset7t23['energytypenr']= 26
    yset7t23['energytype']= "26 - Voertuigbrandstoffen"
    gr3iusdf= pd.concat ( [yrindat,yset7t23]) 
    gr3iusdf=gr3iusdf[gr3iusdf['energytypenr'].isin ({0,23,26})].copy()
    gr3iusdf['energytype']=gr3iusdf['energytype'].where(gr3iusdf['energytypenr']!=0,'0 - Elektriciteit')
#    print(gr3iusdf)
    v3=(gr3iusdf[['volume','energytypenr','jaar']].groupby(['energytypenr','jaar']).agg('sum') ).reset_index()
#    print(v3)
    v3['regklimmon23_TJ'] = v3['energytypenr'].map(regklimmon23GWh_map)
    v3['regklimmon23rat'] = v3['volume']/ v3['regklimmon23_TJ'] 
    v3=v3.merge(landverbrcatm,how='left')
    v3['regklimmonrat'] = v3['volume']/ v3['fromklimmon_GWh'] 
    print(v3)
    return (gr3iusdf)

gr3usdf=mkcombiset(egasyr)


# -
def cntrec(indf):
    tstcyr=indf[['volume','energytype','jaar']].groupby(['energytype','jaar']).agg('count')
    display(tstcyr)
cntrec(gr3usdf)    


def mkuurpl3gr(df,gtype,grprfx,my_yrtomodel,labpl):
    sns_plot=sns.lineplot(data=df,x="validfrom",y="volume",hue='energytype',ci=None) 
    plt.title("uurwaarden "+gtype+my_yrtomodel)
    plt.ylabel("Uurvermogen (GW) of (Gwh/hr)")
    plt.legend(bbox_to_anchor=(labpl, 0.99), loc=0, borderaxespad=0.)
    figname = "../output/"+grprfx+"tot3gr"+my_yrtomodel+'.png';
    sns_plot.figure.savefig(figname,dpi=300) 
mkuurpl3gr(gr3usdf,"verbruik ",'gebr',yrtomodel,0.3)


def mkuurpl3grc(df,gtype,grprfx,my_yrtomodel):
    gr3usdfc=df.copy(deep=False)
    gr3usdfc['volcum']=gr3usdfc.groupby(['energytype'])['volume'].cumsum()
    totverbruik = gr3usdfc['volume'].sum()
    title=  ("Opbouw %s%s: 3 groepen\n totaal %.0f GWh /jaar, %.0f GWh /dag" %(
        gtype,my_yrtomodel,totverbruik,totverbruik/365))
    sns_plot= sns.lineplot(data=gr3usdfc,x="validfrom",y="volcum",hue='energytype',ci=None) 
    plt.title(title)
    plt.ylabel("Cumulatief verbruik (Gwh)")
    plt.legend(bbox_to_anchor=(0.05, 0.95), loc=2, borderaxespad=0.)
    figname = "../output/"+grprfx+"tot3grc"+my_yrtomodel+'.png';
    sns_plot.figure.savefig(figname,dpi=300) 
mkuurpl3grc(gr3usdf,"verbruik ",'gebr',yrtomodel)    

#bereken totaal verbruik, voor verder model
yset7t0i=mkrestcat(gr3usdf,{0:1,23:1,26:1},0)
#print(yset2t23_2023_sum+ yset7t23_2023_sum+ yset1t0_2023_sum )
yset7t0yrs= yset7t0i[['volume','energytype','jaar']].groupby(['energytype','jaar']).agg(['sum','count'])
yset7t0yrs


def addvoorwarmte(egasindf,yset7t0l):
    voorwarmte = egasindf[egasindf['energytypenr'].isin ({23})] . rename(columns={"volume":"gasvbr"})
    voorwarmte ["warmtevbr"]=  voorwarmte ["gasvbr"] - (0.5*voorwarmte ["gasvbr"].min())  
    wstat=voorwarmte[['gasvbr','warmtevbr','energytype','jaar']].groupby(['energytype','jaar']).agg('sum')
    wstat['wfrac'] = wstat ["warmtevbr"]/ wstat ["gasvbr"]
    wstat['basegas'] = wstat ["gasvbr"]- wstat ["warmtevbr"]
    print(wstat)
    yset7t0r=yset7t0l.merge ( voorwarmte[['warmtevbr',"validfrom"]])
    return (yset7t0r)
yset7t0=addvoorwarmte(gr3usdf,yset7t0i)
yset7t0yrs= yset7t0[['volume','warmtevbr','energytype','jaar']].groupby(['energytype','jaar']).agg('sum')
yset7t0yrs

# +
#nu zelfde excercitie voor opwek
# -

opwkyrin=egasyr[egasyr['energytypenr'].isin ({1,2,17})].copy()
mkuurpl3gr(opwkyrin,"opwek ",'opw',yrtomodel,0.8)

opwkpyrs=opwkyrin[['volume','energytype','jaar']].groupby(['energytype','jaar']).agg('sum')*3.6
opwkpyrs=opwkpyrs.reset_index()
opwknormyr=2025
opwkpyrs=opwkpyrs.merge (opwkpyrs[opwkpyrs['jaar'] ==opwknormyr] [['volume','energytype']].
                                rename(columns={'volume':'refvolume'}) )
opwkpyrs['reffrac'] = opwkpyrs['volume'] / opwkpyrs['refvolume'] 
opwkpyrs

opwkyr = opwkyrin.merge (opwkpyrs [['reffrac','energytype','jaar']] )
opwkyr ['volume'] = opwkyr ['volume'] / opwkyr ['reffrac'] 
opwkyr = opwkyr .drop(columns=['reffrac'] )
mkuurpl3gr(opwkyr,"opwek ",'opw',yrtomodel,0.8)

cntrec(opwkyr)

mkuurpl3grc(opwkyr,"opwek ",'opw',yrtomodel)

# +
#inst_opw bepaalt opwek instelling
glb_inst_opw='A'
inst_str=yrtomodel+glb_inst_opw

some_string="""inst,windmult,zonrel,omschr
A,9.0,1,evenredig zon-wind
B,12,0.5,meer wind
C,6,2.5,meer zon
D,7,1,energieneutraal+6%"""
#read CSV string into pandas DataFrame
param_opw_df= pd.read_csv(io.StringIO(some_string), sep=",").set_index('inst')
print(param_opw_df)

def get_param_opw(yrstr,inst_opw):
    param_opw = param_opw_df.to_dict('index')[inst_opw]
    ytmult=1
    if yrstr=='2023':
        ytmult=1.1
    param_opw['windmult']= (param_opw['windmult']*ytmult)
    return(param_opw)

def mkusopw(opwkyrindf,yset7t0df,yrstr,inst_opw):
    param_opw=get_param_opw(yrstr,inst_opw)
    print(param_opw)

#    cntrec(opwkyrindf)
    yset8t0=mkrestcat(opwkyrindf,{1:param_opw['windmult'],
                               2:param_opw['windmult'] * param_opw['zonrel'],
                               17:param_opw['windmult']},1)
#    totvol=yset8t0[['volume','energytype']].groupby('energytype').agg('sum')*3.6
#    print(totvol)
    cntrec(yset8t0)
#    print (yset8t0.sort_values("validfrom"))
    oframe= yset8t0[['volume',"validfrom",'jaar']].rename(columns={"volume":"opwek"})
                 
    cframe = oframe.merge ( yset7t0df[['volume','warmtevbr',"validfrom"]].rename(
           columns={"volume":"verbruik"}) ).sort_values("validfrom").copy()    
    cframe ["balans"]= cframe ["opwek"]- cframe ["verbruik"]
    cframe ["cumbalans"]= cframe ["balans"].cumsum()
    totvol=cframe[['verbruik','opwek','balans','warmtevbr','jaar']].groupby(['jaar']).agg('sum')
    print(totvol)
    return (cframe)
               
landyrframe= mkusopw(opwkyr,yset7t0,yrtomodel,glb_inst_opw)
landyrframe.dtypes            


# -

def mkovplot(dfin,yrstr,my_inst_opw,my_inst_str,ax):
    param_opw=get_param_opw(yrstr,my_inst_opw)
#    print(param_opw)
    df=dfin.copy(deep=False)
    avgverbruik=df['verbruik'].mean()    
    otit=("Opwek wind * %.1f + zon * %.1f (max= %.0f)"% (       
       param_opw['windmult'] ,param_opw['windmult'] * param_opw['zonrel'] , df["opwek"].max()))
    vtit=("Verbruik (avg = %0.f max= %.0f)"% (
       avgverbruik,df["verbruik"].max() ) )       
    sns.lineplot(ax=ax,data=df,x="validfrom",y="opwek",ci=None,label=otit) 
    sns_plot=sns.lineplot(ax=ax,data=df,x="validfrom",y="verbruik",ci=None,label=vtit)  
    ptit=("Verbruik %s (avg = %0.f max= %.0f) en wind * %.1f + zon * %.1f (max= %.0f)"% (
       inst_str,avgverbruik,df["verbruik"].max(),
       param_opw['windmult'] ,param_opw['windmult'] * param_opw['zonrel'] , df["opwek"].max()))
    df['gelijktijdig'] = df['verbruik'].where(df['verbruik'] < df['opwek'],df['opwek'] )
#    sns.lineplot(data=df,x="validfrom",y="gelijktijdig",ci=None) 
    opwekrat=df['opwek'].mean() /avgverbruik    
    gelijktrat=df['gelijktijdig'].mean() /avgverbruik
    gtit=("gelijktijdig (%0.f %% verbruik %.0f %% opwek)"% (
       gelijktrat*100, gelijktrat*100/opwekrat) )
    sns_plot=sns.lineplot(ax=ax,data=df,x="validfrom",y="gelijktijdig",
                          ci=None,label=gtit,alpha=0.3,color='black')  
    ptit=("gem dagverbr= %.0f GWh, opwek %0.f %% verbruik"% (
       avgverbruik*24, opwekrat*100) )
    ax.set_title(ptit)
    #ax.legend(bbox_to_anchor=(0.2, 0.99), loc=0, borderaxespad=0.)
    
    ax.set_ylabel("Uurvermogen (GW) of (Gwh/hr)")
    ax.set_xlabel("datum (gegevens per uur)")
    figname = "../output/eneuthr_hr_"+my_inst_str+'.png';
#    sns_plot.figure.savefig(figname,dpi=300) 
    return figname 
fig,ax= plt.subplots(figsize=(10,6))
fig.savefig(
mkovplot(landyrframe,yrtomodel,glb_inst_opw,inst_str,ax)    ,dpi=300) 

# balans over het jaar, in GWh
sns.lineplot(data=landyrframe,x="validfrom",y="balans",ci=None) 
plt.title("uurbalansen: positief is overschot opwek")


def cumbalplot(cframe,my_inst_str,ax,color):
    cframe ["cumbalans"]= cframe ["balans"].cumsum()
    lastw=cframe.tail(1)["cumbalans"]
    totv=(cframe ["verbruik"].sum())
    lab= "overschot = %.0f (= %.1f %% van verbruik)" % (
         lastw,100*lastw/totv)
    sns_plot=sns.lineplot(ax=ax,data=cframe,x="validfrom",y="cumbalans",
                          ci=None,label=lab,color=color) 
    title= "cumulatieve uurbalansen %s" % (
         inst_str)
    ax.set_title(title)
    figname = "../output/eneuthr_cum_"+inst_str+'.png';
    return(figname)
fig,ax= plt.subplots(figsize=(10,6))
fig.savefig(
cumbalplot(landyrframe,inst_str,ax,'green')    ,dpi=300)


#extra opwek (nodig vanwege opslag verliezen) relatief t.o.v. jaarverbruik
def plotreovsch(cframe):
    cframe ["cumbalansrel"]= cframe["cumbalans"]/ (cframe ["verbruik"].sum())
    sns.lineplot(data=cframe,x="validfrom",y="cumbalansrel",ci=None) 
    plt.title("cumulatieve uurbalansen als fractie van jaarverbruik")
plotreovsch(landyrframe.copy(deep=False))    


#grafiek: te lezen vanaf links
#als je opslag laadt vanaf een bepaalde grens (GW , of GWh/uur), hoe veel 
#totaal niet direct verbruikt vermogen (GWh) is dan per jaar beschikbaar ?
def balansstats(df,col,totpwr,my_inst_str,ax,color):
    balansfreq0=df[[col]].sort_values(col,ascending=False).copy().reset_index()
    balansfreq0['n']=balansfreq0.index
    balansfreq0['totpwr']=balansfreq0[col].cumsum()
    hrload= (balansfreq0[col] >0).sum()
    hrdis= (balansfreq0[col] <0).sum()
    if col== 'balans':
        tit="laad/ontlaad statistiek"
        lab="uren +: %d (%d %%), uren - %d (%d %%)"%(hrload,hrload*(100/(24*365)),hrdis,hrdis*(100/(24*365)))
    else:
        avg= balansfreq0[col].mean()
        hrlow= (balansfreq0[col] < avg/10).sum()
        tit=" %s %s"%(col,inst_str)
        lab=(" %s average %.1f, hrs below %.2f : %.0f"%(col,avg,avg/10,hrlow))
    if totpwr:
        p=sns.lineplot(ax=ax,data=balansfreq0,y="totpwr",x="balans",ci=None,color=color,label=lab) 
        dfc=balansfreq0.copy(deep=False)
        dfc['vert']=dfc["balans"]*0
        p=sns.lineplot(ax=ax,data=dfc,y="totpwr",x="vert",alpha=0.2,ci=None,
                       estimator=None,color=color,label="") 
        ax.set_xlabel("bij overschotten boven dit vermogen (GW)")
        ax.set_ylabel("blijft jaarlijks dit over (GWh)")
        figname = "../output/"+col+"iocum_"+my_inst_str+'.png';
    else:
        p=sns.lineplot(ax=ax,data=balansfreq0,x="n",y=col,ci=None,color=color,label=lab) 
        dfc=balansfreq0.copy(deep=False)
        dfc['hor']=dfc["n"]*0
        p=sns.lineplot(ax=ax,data=dfc,x="n",y='hor',alpha=0.2,ci=None,color=color,label="") 
        ax.set_xlabel("uren in jaar")
        ax.set_ylabel("ycol")        
        figname = "../output/"+col+"iohrs_"+my_inst_str+'.png';
    ax.set_title(tit)        
    return figname 
fig,ax= plt.subplots(figsize=(10,6))
fig.savefig(
balansstats(landyrframe, "balans",True,inst_str,ax,'green'),dpi=300) 

#grafiek: te lezen vanaf links
#als je opslag laadt vanaf een bepaalde grens (GW , of GWh/uur), hoe veel 
#totaal niet direct verbruikt vermogen (GWh) is dan per jaar beschikbaar ?
balansfreq0=landyrframe [["balans"]].sort_values("balans",ascending=False).copy().reset_index()
balansfreq0['n']=balansfreq0.index
balansfreq0['totpwr']=balansfreq0['balans'].cumsum()
sns.lineplot(data=balansfreq0,y="totpwr",x="balans",ci=None) 

fig,ax= plt.subplots(figsize=(10,6))
balansstats(landyrframe, "opwek",False,inst_str,ax,'green')

#keuzes modellen
glb_inst_long='A'
glb_inst_short='A'
inst_str=yrtomodel+glb_inst_opw+glb_inst_long+glb_inst_short

# +
#eerste beschrijving van long-term storage: opgeslagen vermogen in GWh
#gaat uit van snel laden, grote verliezen bij laden en weinig verlies over tijd
#grafiek mag niet onder 0 uit komen, en moet aan einde royaal hoger dan begin uit komen
#bij een longstthresh hoger dan 80 raakt de short term overvol in zomer
some_string="""inst,ndayslong,steff,ststart,stthresh,tfact,athresh,afact,ofact,yrhalf,omschr
A,4,0.4,30e3,0,0,15,0.9,1.01,2,4 dgn geleidelijke opslag
B,4,0.4,30e3,70,1,0,0,1.01,2,4 dgn alleen piek opslag
C,2,0.4,30e3,0,0,3,0.95,1.01,2,2 dgn geleidelijke opslag
D,7,0.4,30e3,0,0,15,0.9,1.01,2,7 dgn geleidelijke opslag
E,2,3.0,60e3,0,0,15,0.9,1.01,2,2 dgn warmte eff"""
    #read CSV string into pandas DataFrame    
param_longdf= pd.read_csv(io.StringIO(some_string), sep=",").set_index('inst')

some_string="""inst,steff,ststart,wkhalf,dayscap,omschr
A,0.9,4000,4,7,4 dgn cap
B,0.9,4000,4,7,kopie van A"""
    #read CSV string into pandas DataFrame
param_shortdf= pd.read_csv(io.StringIO(some_string), sep=",").set_index('inst')


# +
def shortst_init_decay(my_inst_short):
    param_short= param_shortdf.to_dict('index')[my_inst_short]
    shortsteff=param_short['steff']
    shortststart=param_short['ststart']
    shorthalfw=param_short['wkhalf']*7*24
    #bereken gemiddelde verliezen korte termijn
    avgshusg = shortststart * (np.log(2)/shorthalfw) / shortsteff
    return avgshusg

def add_longst_io(df,my_inst_long,avgshusg,my_inst_str,ax,color):
    param_long=param_longdf.to_dict('index')[my_inst_long]
    print(param_long)

    nhrslong=24*param_long['ndayslong']
    #longsteff=param_long['steff']    
    #bereken de outflow per uur om het short-term storage te onderhouden
    #dit is een gemiddeld systeem verlies dat het short-term storage ieder uur gemiddeld verbruikt

    #voeg gemiddelde verliezen korte termijn toe aan balans
    balans1= df ["balans" ] - avgshusg
    repyr=pd.concat ( [ balans1, balans1[0:nhrslong]  ] ).cumsum()
    bcalc= ( repyr.shift(-nhrslong)- repyr)/nhrslong
    df ["multdaybalans" ]= bcalc[0:len(df.index)]
    df ["multdaybalanssm" ]= np.convolve(df ["multdaybalans" ],
                                             np.ones(nhrslong)/nhrslong,mode='same' )
    df ["tolongterm" ] = ( df ["multdaybalans" ] *  param_long['ofact'] ) . where(
           df ["multdaybalans" ]<0,
           param_long['afact'] *df ["multdaybalans" ]* (df ["multdaybalans" ] >param_long['athresh'] )) + ( 
            ( param_long['tfact'] * df ["balans" ] ) . where(
               df ["balans" ]>param_long['stthresh'],0) )
    df ["longtermst" ] = df ["tolongterm" ] . where(
          df ["tolongterm" ]<0,df ["tolongterm" ] *param_long['steff']
           ) .cumsum() +param_long['ststart']
#    plt.clf()
    sns_plot=sns.scatterplot(ax=ax,data=df,x="validfrom",y="tolongterm",color=color) 
    title= 'Long-time storage in/out %s: out smooth %.0f days, need * %.2f\n in if hour > %0d GW  %.2f + smooth in > %.0d GW * %.2f'%(
        my_inst_str,param_long['ndayslong'],param_long['ofact'],param_long['stthresh'],param_long['tfact'],
           param_long['athresh'],param_long['afact'])
    ax.set_ylabel("Uurbalans (GW of GWh)")
    ax.set_title(title)
    figname = "../output/longst_io_"+my_inst_str+'.png';
    return figname 
fig,ax= plt.subplots(figsize=(10,6))
fig.savefig(
  add_longst_io(landyrframe ,glb_inst_long,shortst_init_decay( glb_inst_short),
                inst_str,ax,'green')   ,dpi=300) 
# -

sns.lineplot(data=landyrframe,x="validfrom",y="longtermst",ci=None) 

fig,ax= plt.subplots(figsize=(10,6))
balansstats(landyrframe, "tolongterm",False,inst_str,ax,'green')


#longststart
def add_longst_mem(df,my_inst_long,sizmul,my_inst_str,ax,color):
    param_long=param_longdf.to_dict('index')[my_inst_long]
    ststart = sizmul * param_long['ststart']
    df ["longtermsd" ] = memfunc(df ["tolongterm" ] . where(
          df ["tolongterm" ]<0,df ["tolongterm" ] *param_long['steff']),
          ststart,param_long['yrhalf']*365*24,0,4*ststart)  
    empty=df [df ["longtermsd" ] ==0 ].copy().reset_index()
    stoend= df.tail(1)["longtermsd"]
    stomax=df["longtermsd"].max()
#    sns.lineplot(ax=ax,data=df,x="validfrom",y="longtermst",label="cum. balans",ci=None) 
    multk=0.001
    spar =('ini %.0fk max = %.0fk end=%.0fk '% (ststart*multk,stomax*multk,stoend*multk))
    if empty.size !=0:
        print("WARNING: storage gets empty")
        print(empty["validfrom"])
        spar=spar+ "GOT EMPTY "
    else:    
        print("OK: storage does not get empty")
    if (stoend< ststart).any()  :
        print("WARNING: storage depleted over year %.0f < %.0f" % (stoend , ststart))
        spar=spar+ "DEPLETED "
    else:        
        print("OK: storage surplus over year %.0f >%.0f" % (stoend , ststart))

    sns_plot=sns.lineplot(ax=ax,data=df,x="validfrom",y="longtermsd",label=spar,color=color,ci=None) 
    dfc=df.copy(deep=False)
    dfc['initv'] =ststart 
    sns_plot=sns.lineplot(ax=ax,data=dfc,x="validfrom",y="initv",alpha=0.2,label="",color=color,ci=None) 
    
    title= 'Long-time storage filling '+my_inst_str
    title = title +('\nstorage cycle eff %.0f %%, half-time %.1f yr'% (
        param_long['steff']*100,param_long['yrhalf']))
    ax.set_title(title)
    ax.set_ylabel("Opslag vulling (GWh)")
    ax.legend(bbox_to_anchor=(0.05, 0.95), loc=2, borderaxespad=0.)
    figname = "../output/longst_fill_"+my_inst_str+'.png';
    return (figname)
#    sns_plot.figure.savefig(figname,dpi=300) 
fig,ax= plt.subplots(figsize=(10,6))
fig.savefig(
add_longst_mem(landyrframe ,glb_inst_long,1.0,inst_str,ax,'green')    ,dpi=300)     


# +
### Korte termijn
# -

#dan moet de rest opgevangen door korte termijn
def add_shortst_io(df,my_inst_long,my_inst_short,my_inst_str,ax,color):
    param_short= param_shortdf.to_dict('index')[my_inst_short]
    print(param_short)

    shortsteff=param_short['steff']
    shortststart=param_short['ststart']
    df ["toshortterm" ] = df ["balans" ] -df ["tolongterm" ]
    df ["shorttermst" ] = df ["toshortterm" ] . where(
          df ["toshortterm" ]<0,df ["toshortterm" ] *shortsteff) .cumsum() +shortststart
    sns_plot=sns.lineplot(ax=ax,data=df,x="validfrom",y="toshortterm",color=color,ci=None) 
    #sns.lineplot(data=df,x="validfrom",y="shorttermst",ci=None) 
    param_long=param_longdf.to_dict('index')[my_inst_long]
    title= 'Short-time storage usage\nLong out smooth %.0f days, in if hour > %0d GW'%(
          param_long['ndayslong'],param_long['stthresh'])
    ax.set_title(title)
    figname = "../output/shortst_io_"+my_inst_str+'.png';
    return(figname)
fig,ax= plt.subplots(figsize=(10,6))
fig.savefig(
add_shortst_io(landyrframe ,glb_inst_long,glb_inst_short,inst_str,ax,'green')     ,dpi=300)     

#opslag zonder halfwaardetijd en maxima
sns.lineplot(data=landyrframe,x="validfrom",y="shorttermst",ci=None) 

fig,ax= plt.subplots(figsize=(10,6))
balansstats(landyrframe, "toshortterm",False,inst_str,ax,'green')


# +
#nu opslag model toepassen
# -

def add_shortst_mem(df,my_inst_short,sizmul,my_inst_str,ax,color):
    param_short= param_shortdf.to_dict('index')[my_inst_short]
    shortsteff=param_short['steff']
    shortststart=sizmul*param_short['ststart']

    totverbruik = df['verbruik'].sum()
    #print('totverbruik %.1f'%(totverbruik))
    shortmaxsto=totverbruik*param_short['dayscap']/365
    shorthalfw=param_short['wkhalf']*7*24
    df ["shorttermsd" ] = memfunc(df ["toshortterm" ] . where(
          df ["toshortterm" ]<0,df ["toshortterm" ] *shortsteff) 
                                           ,shortststart,shorthalfw,0,shortmaxsto)  
    empty=df [df ["shorttermsd" ] ==0 ].copy().reset_index()
    shortstend=  df.tail(1)["shorttermsd"] 
    stomax=df["shorttermsd"].max()
    multk=0.001
    spar =('ini %.0fk max = %.0fk end=%.0fk '% (shortststart*multk,stomax*multk,shortstend*multk))    
    
    if empty.size !=0:
        print("WARNING: storage gets empty")
        print(empty["validfrom"])
        spar=spar+ "GOT EMPTY "
    else:    
        print("OK: storage does not get empty")
    if (shortstend< shortststart).any()  :
        print("WARNING: storage depleted over year %.0f < %.0f" % (shortstend , shortststart))        
        spar=spar+ "DEPLETED "
#    plt.clf() 
    sns_plot=sns.lineplot(ax=ax,data=df,x="validfrom",y="shorttermsd",label=spar ,color=color,ci=None) 
    dfc=df.copy(deep=False)
    dfc['initv'] =shortststart 
    sns_plot=sns.lineplot(ax=ax,data=dfc,x="validfrom",y="initv",alpha=0.2,label="",color=color,ci=None) 
    
    title= 'Short-time storage filling '+my_inst_str
    title = title +('\nstorage cycle eff %.0f %%, half-time %.0f days'% (
        shortsteff*100,shorthalfw/24))
    ax.set_ylabel("Opslag vulling (GWh)")
    ax.set_title(title)
    figname = "../output/shortst_fill_"+my_inst_str+'.png';
    return (figname)
fig,ax= plt.subplots(figsize=(10,6))
fig.savefig(
add_shortst_mem(landyrframe ,glb_inst_short,1.0,inst_str,ax,'green')   ,dpi=300)         


# +
#nu run opnieuw met andere parameters
def run_again (cdf_discard,my_inst_opw, my_inst_long,my_inst_short):
    my_inst_str=yrtomodel+my_inst_opw
    figcmbl, axcmbl = plt.subplots(nrows=3, ncols=3,figsize=(10, 8))
    figcmbl.tight_layout(pad=4)
    cdf= mkusopw(opwkyr,gr3usdf,yset7t0,yrtomodel,my_inst_opw)
    mkovplot(cdf,yrtomodel,my_inst_opw,my_inst_str,axcmbl[0,0]) 
#    plt.show()
    my_inst_str=yrtomodel+my_inst_opw+my_inst_long+my_inst_short
    cumbalplot(cdf,my_inst_str,axcmbl[0,1],'green')    
    balansstats(cdf, "balans",True,my_inst_str,axcmbl[0,2],'green')
    add_longst_io(cdf ,my_inst_long,shortst_init_decay( my_inst_short),my_inst_str,axcmbl[1,0],'green'  )    
#    plt.clf()
    balansstats(cdf, "tolongterm",False,my_inst_str,axcmbl[1,1],'green')
#    plt.clf()
    add_longst_mem(cdf ,my_inst_long,1.0,my_inst_str,axcmbl[1,2],'green' )   
#    plt.show()
#    plt.clf()
    add_shortst_io(cdf ,my_inst_long,my_inst_short,my_inst_str,axcmbl[2,0],'green')        
#    plt.clf()
    balansstats(cdf, "toshortterm",False,my_inst_str,axcmbl[2,1],'green')
#    plt.clf()
    add_shortst_mem(cdf ,my_inst_short,1.0,my_inst_str,axcmbl[2,2],'green') 
    cfiglname = "../output/cmb_"+inst_str+'.png';
    figcmbl.savefig(cfiglname,dpi=300) 
    return figcmbl
    
run_again (landyrframe.copy(),glb_inst_opw,'D','B')  

# +
#nieuwe manier van warmte apart
# -

some_string="""inst,long_w,short_w,wlongfrac,wshuse,wpompfr,initrezis,omschr
T,_,_,0,0,1.0,1.0,Niets naar warmte
W,_,_,0.91,1,0.05,0.25,Eerste poging
E,E,_,0.91,1,0.05,0.25,Warmte eff long"""
    #read CSV string into pandas DataFrame
param_warmlosdf= pd.read_csv(io.StringIO(some_string), sep=",").set_index('inst')


# +
def mkovplotw(dfin,yrstr,my_inst_opw,my_inst_str,ax):
    param_opw=get_param_opw(yrstr,my_inst_opw)
#    print(param_opw)
    df=dfin.copy(deep=False)
    df['nietwarmte'] = df ["verbruik"] - df["warmtevbr"]
    sns.lineplot(ax=ax,data=df,x="validfrom",y="warmtevbr",ci=None,label='warmte',color='red') 
    sns_plot=sns.lineplot(ax=ax,data=df,x="validfrom",y="nietwarmte",ci=None,
                          label='nietwarmte',color='blue')  
    avgverbruik=df['verbruik'].mean()    

#    ax.set_title(ptit)
    ax.legend(bbox_to_anchor=(0.75, 0.99), loc=0, borderaxespad=0.)
    ax.set_ylabel("Uurvermogen (GW) of (Gwh/hr)")
    ax.set_xlabel("datum (gegevens per uur)")
    figname = "../output/eneuthr_hr_"+my_inst_str+'.png';
#    sns_plot.figure.savefig(figname,dpi=300) 
    return figname 


# +
def run_againw (cdf_discard,my_inst_opw, my_inst_long,my_inst_short,my_inst_w):
    param_w= param_warmlosdf.to_dict('index')[my_inst_w]

    my_inst_str=yrtomodel+my_inst_opw

    figcmbw, axcmbw = plt.subplots(nrows=3, ncols=3,figsize=(10, 8))
    figcmbw.tight_layout(pad=4)
    cdf= mkusopw(opwkyr,gr3usdf,yset7t0,yrtomodel,my_inst_opw)
    mkovplot(cdf,yrtomodel,my_inst_opw,my_inst_str,axcmbw[0,0]) 
    
    my_inst_str=yrtomodel+my_inst_opw+my_inst_long+my_inst_short+my_inst_w   
    mkovplotw(cdf,yrtomodel,my_inst_opw,my_inst_str,axcmbw[0,2]) 

    cdf_e = cdf.copy()
    cdf_e['balans'] = cdf_e['balans'] +( 1- param_w['wpompfr'] )*cdf_e['warmtevbr']

    cumbalplot(cdf_e,my_inst_str,axcmbw[0,1],'blue')    

    add_longst_io(cdf_e ,my_inst_long,shortst_init_decay( my_inst_short),my_inst_str+'E',axcmbw[1,0],'blue')   
    wlongtermfact=param_w['wlongfrac']
    winitrezis=param_w['initrezis']
    cdf_e ["tolongtermw" ] = ( wlongtermfact) *cdf_e ["tolongterm" ].where (
              cdf_e ["tolongterm" ] >0,0)
    cdf_e ["tolongterm" ] = cdf_e ["tolongterm" ] - cdf_e ["tolongtermw" ]
    #sns_plot=sns.scatterplot(data=cdf_e,x="validfrom",y="tolongterm") 
    balansstats(cdf_e, "tolongterm",False,my_inst_str+'E',axcmbw[1,1],'blue')

    add_longst_mem(cdf_e ,glb_inst_long,winitrezis,my_inst_str+'E',axcmbw[1,2],'blue') 
    cdf_e['balans'] = cdf_e['balans'] - cdf_e ["tolongtermw" ]  

    add_shortst_io(cdf_e ,my_inst_long,my_inst_short,my_inst_str+'E',axcmbw[2,0],'blue') 
    balansstats(cdf_e, "toshortterm",False,my_inst_str+'E',axcmbw[2,1],'blue')
    add_shortst_mem(cdf_e ,my_inst_short,1.0,my_inst_str+'E',axcmbw[2,2],'blue') 

    cdf_w = cdf_e.copy()
    cdf_w['balans'] = - cdf_w['warmtevbr'] *param_w['wshuse']
    
    my_inst_long_w=param_w['long_w']
    if (my_inst_long_w == '_'):
        my_inst_long_w = my_inst_long
    my_inst_short_w=param_w['short_w']
    if (my_inst_short_w == '_'):
        my_inst_short_w = my_inst_short
    add_longst_io(cdf_w ,my_inst_long_w,winitrezis*param_w['wshuse'] *shortst_init_decay( my_inst_short_w),
                  my_inst_str+'W',axcmbw[1,0],'red')    
    cdf_w ["tolongterm" ] = cdf_w ["tolongterm" ] +cdf_w ["tolongtermw" ] 
    #sns_plot=sns.scatterplot(data=cdf_w,x="validfrom",y="tolongterm") 
    balansstats(cdf_w, "tolongterm",False,my_inst_str+'W',axcmbw[1,1],'red')
    add_longst_mem(cdf_w ,my_inst_long_w,param_w['wshuse'] ,my_inst_str+'W',axcmbw[1,2],'red') 
    cdf_w['balans'] = cdf_w['balans'] + cdf_w ["tolongtermw" ]
    cumbalplot(cdf_w,my_inst_str,axcmbw[0,1],'red')    

    add_shortst_io(cdf_w ,my_inst_long_w,my_inst_short_w,my_inst_str+'W',axcmbw[2,0],'red') 
    balansstats(cdf_w, "toshortterm",False,my_inst_str+'W',axcmbw[2,1],'red')
    add_shortst_mem(cdf_w ,my_inst_short_w,winitrezis*param_w['wshuse'],my_inst_str+'W',axcmbw[2,2],'red')    
                         
    cfigwname = "../output/cmbw_"+my_inst_str+'.png';
    figcmbw.savefig(cfigwname,dpi=300) 
    return figcmbw                         
                         
run_againw (landyrframe.copy(),glb_inst_opw,glb_inst_long,glb_inst_short,'E')
1


# +
#oude manier van warmte

# +
### deel lange termijn opname voor warmte
def calclong_warmfrac(dfin,my_inst_long,my_inst_short,my_inst_str):
    df=dfin.copy()
    param_long=param_longdf.to_dict('index')[my_inst_long]
    print(param_long)
    nhrslong=24*param_long['ndayslong']
    balans1= df ["warmtevbr" ] 
    repyr=pd.concat ( [ balans1, balans1[0:nhrslong]  ] ).cumsum()
    bcalc= ( repyr.shift(-nhrslong)- repyr)/nhrslong
    df ["multdaywarmtevbr" ]= bcalc[0:len(df.index)]
    df ["multdaywarmtevbrsm" ]= np.convolve(df ["multdaywarmtevbr" ],
                                             np.ones(nhrslong)/nhrslong,mode='same' )
    df ["fromlongterm"] = - df ["tolongterm"].where(df ["tolongterm"]<0,0)
#    df ["longtermnaarwarmte"] = df ["multdaywarmtevbrsm" ]/ df ["fromlongterm"] 
    df ["longtermnaarwarmte"] = df ["fromlongterm"].where (df ["fromlongterm"]< df ["multdaywarmtevbrsm" ], 
                                                           df ["multdaywarmtevbrsm" ])
    fig, ax1 = plt.subplots(figsize=(10, 6))
    sns.scatterplot(data=df, x="validfrom",y= "fromlongterm",label="Totaal uit long",ax=ax1 )
    sns.scatterplot(data=df, x="validfrom",y= "longtermnaarwarmte" ,label="Als warmte uit long",ax=ax1)
    # Create and plotting the secondary y-axis data
    ax2 = ax1.twinx()
    df ["fromlongtermc"] =df ["fromlongterm"] .cumsum()
    df ["longtermnaarwarmtec"] =df ["longtermnaarwarmte"] .cumsum()
    sns.lineplot(data=df, x="validfrom",y= "fromlongtermc" ,label="Totaal uit long",ax=ax2,ci=None)
    sns.lineplot(data=df, x="validfrom",y= "longtermnaarwarmtec" ,label="Als warmte uit long",ax=ax2,ci=None)
    # Set labels with matching colors
    ax1.set_ylabel('Vermogen (GW/ GWh/hr)')
    ax2.set_ylabel('Cumulatieve energie (GWh)')
    ax1.legend( loc='upper left')
    ax2.legend( loc='upper center')
#    sns.scatterplot(data=df, x="validfrom",y= "longtermnaarwarmte" )
    
calclong_warmfrac(landyrframe ,glb_inst_long,glb_inst_short,inst_str)
# -

#regressietest op lang model A voor zo lang short model B zelfde parameters heeft als A
run_again (landyrframe.copy(),glb_inst_opw,'D','A')  

run_again (landyrframe.copy(),glb_inst_opw,'C','A')  


# +
def optlst(indf):
    lcol= indf.index.values+" - "+indf['omschr']
    return lcol.tolist()

def recalc(my2_inst_jaar,my2_inst_verbr,my2_inst_opw,my2_inst_long='B',my2_inst_short='A',my2_inst_warm='T'):
    if my2_inst_warm[0:1] =='T':
        run_again (
            landyrframe.copy(),       my2_inst_opw[0:1],       my2_inst_long[0:1],       my2_inst_short[0:1]  )
    else:
        run_againw (
            landyrframe.copy(),       my2_inst_opw[0:1],       my2_inst_long[0:1],       my2_inst_short[0:1] ,
              my2_inst_warm[0:1] )
        
    
interact(
   recalc ,
       my2_inst_jaar=Dropdown(options=[yrtomodel], description='Data jaar:'),    
       my2_inst_verbr=Dropdown(options=optlst(param_verbr_df), description='Verbruik:'),    
       my2_inst_opw=Dropdown(options=optlst(param_opw_df), description='Opwek mix:'),
       my2_inst_long=Dropdown(options=optlst(param_longdf), description='Long-term:'),
       my2_inst_short=Dropdown(options=optlst(param_shortdf), description='Short-term:') ,     
       my2_inst_warm=Dropdown(options=optlst(param_warmlosdf), description='Warmte Los:')      
)
